BEGIN;

/**/
-- D'abord on supprime les tables si elles existent. Au cas ou on "rejoue" le script de création de la structure des données.
DROP TABLE IF EXISTS "list",
"card",
"tag",
"card_has_tag";

-- Maintenant on peut recréer
CREATE TABLE IF NOT EXISTS "list" (
    -- INT + GENERATED BY DEFAULT AS IDENTITY remplance SERIAL qui n'était standard en SQL
    "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- On peut rajouter des contraintes supplémentaire au fait que les valeurs des champs doivent être non vide (NOT NULL), par exemple UNIQUE qui précise qu'il ne peut pas y avoir de doublon de cette valeur dans cette colonne
    "name" TEXT NOT NULL UNIQUE,
    "position" INTEGER NOT NULL DEFAULT 0,
    -- Une colonne created_at est utile pour garder une traçe de la date ou a été créer un enregistrement. On ajoute la date du jour avec la fonction now())
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
    -- Par contre le champ chargé de garder une traçe de la dernière mise à jour peut -être vide au moment de l'insertion
    "updated_at" TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS "card" (
    "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "content" TEXT NOT NULL,
    "position" INTEGER NOT NULL DEFAULT 0,
    "color" TEXT NOT NULL DEFAULT '#dedede',
    -- Afin de réprésenter l'association entre une carte est une liste on fait référence à l'id d'une liste dans la colonne list_id
    "list_id" INT NOT NULL REFERENCES "list"("id") ON DELETE CASCADE,
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
    "updated_at" TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS "tag" (
    "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" TEXT NOT NULL,
    "color" TEXT NOT NULL DEFAULT '#fff',
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
    "updated_at" TIMESTAMPTZ
);

-- Et pour finir la table d'association
CREATE TABLE IF NOT EXISTS "card_has_tag" (
    -- Afin de permettre à la BDD de supprimer, en même temps un enregistrement qui fait référence à un autre enregistrement d'une autre table, que l'enregistrement lui-même, on peut ajouter "ON DELETE CASCADE". Cela évitera l'erreur de contrainte à la suppression de l'enregistrement de base.
    "card_id" INT NOT NULL REFERENCES "card"("id") ON DELETE CASCADE,
    "tag_id" INT NOT NULL REFERENCES "tag"("id") ON DELETE CASCADE,
    -- cela reste intéressant de savoir quand a été faite l'association
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
    -- Et pour la mise à jour ? Non par utile, parce que c'est une association, et une association on la créer ou on la supprime, on en modifie jamais une association.
    PRIMARY KEY ("card_id", "tag_id")
);

/*
 SEEDING
 Cela permet d'ajouter des données fictives à une BDD, afin d'exécuter des test pendant le developpment d'une application.
 Normalement on fait ce seeding dans un fichier séparé, pour ne pas l'exécuter en production.
 */
INSERT INTO
    "list" ("id", "name")
VALUES
    (1, 'Première liste'),
    (2, 'Deuxième liste');

INSERT INTO
    "card" ("id", "content", "color", "list_id")
VALUES
    (1, 'Carte 1', '#f0f', 1),
    (2, 'Carte 2', '#0f0', 1),
    (3, 'Carte 3', '#0f0', 2);

INSERT INTO
    "tag" ("id", "name", "color")
VALUES
    (1, 'Urgent', '#ff0000'),
    (2, 'Help', '#00ff00');

INSERT INTO
    "card_has_tag" ("card_id", "tag_id")
VALUES
    (1, 1),
    (3, 1);

-- Comme on a décider de remplir nous même les id dans les différentes tables, il faut mettre à jour les sequences d'auto incrément des GENERATED … AS IDENTITY
SELECT setval('list_id_seq', (SELECT MAX(id) FROM "list"));
SELECT setval('card_id_seq', (SELECT MAX(id) FROM "card"));
SELECT setval('tag_id_seq', (SELECT MAX(id) FROM "tag"));

COMMIT;

/*
 Template classique de création de table:
 
 CREATE TABLE IF NOT EXISTS "<nom de la table>" (
 "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 
 "created_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
 "updated_at" TIMESTAMPTZ
 );
 */